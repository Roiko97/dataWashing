#include<iostream>
#include<fstream>
#include<vector>
#include<algorithm>
using namespace std;
class Graph{
public:
	int target;//目标结点
	int startT;//出发时间
	int dur;// 持续时间
	int neiId; //出边邻居的id
	int mark;//车辆班次唯一标识符
	Graph(){
		target = 0;
		startT = 0;
		dur = 0;
		neiId = 0;
		mark = 0;
	}
};
bool cmp(Graph g1, Graph g2){
	return g1.target < g2.target;
}
void main()
{
	int MARK = 0; //车辆班次唯一标识符

	fstream read;
	read.open("austin.txt", ios::in);
	/*
		第一行 所有的站点数 所有的线路条数 所有线路的站点和 总的数据量
		第二行 线路id
		第三行 该条线路途径站点id
		第四行 站点id
		第五行 该条线路一共有10班车
	*/
	int Size;
	read >> Size;
	vector<vector<Graph>> route;
	vector<int> index; //记录每个点的出边邻居个数
	route.resize(Size);
	index.resize(Size);
	int loop;
	read >> loop; //一共有loop条线路
	int tmp;
	read >> tmp;
	read >> tmp;
	//    第一行数据读完
	for (int i = 0; i < loop; i++){
		int id;
		read >> id;
		//	第二行数据读完
		int site; // 站点数
		read >> site;
		//	第三行数据读完
		vector<int> tmpSite;
		tmpSite.resize(site);
		for (int j = 0; j < site; j++){
			int site_id;
			read >> site_id;
			//tmpSite.push_back(site_id);
			tmpSite[j] = site_id;

			//	第四行数据读完
			//  保存了所有的id编号

		}
		int fre;// 一共有fre个班次
		read >> fre;
		//	第五行数据读完
		for (int j = 0; j < fre; j++){ // 10躺

			for (int n = 0; n < site - 1; n++){ //初始化向量大小,并且将出度id赋值给该点
				int extendSize = route[tmpSite[n]].size() == 0 ? 1 : route[tmpSite[n]].size() + 1;
				route[tmpSite[n]].resize(extendSize);
				route[tmpSite[n]][extendSize - 1].neiId = tmpSite[n + 1];
			}



			int arrival, start;
			read >> arrival; //开始点的到达无用
			for (int k = 0; k < site-1; k++){ //site站数

				read >> start; //第一行的末
				route[tmpSite[k]][route[tmpSite[k]].size()-1].startT = start;
				route[tmpSite[k]][route[tmpSite[k]].size() - 1].target = tmpSite[k + 1];
				read >> arrival; //第二行的初
				//read.seekp(-1, ios_base::cur);
				route[tmpSite[k]][route[tmpSite[k]].size() - 1].dur = arrival - start;
				route[tmpSite[k]][route[tmpSite[k]].size() - 1].mark = MARK;
			}
			read >> start; //最后一个无用
			MARK++;
		}
	}
	cout << "building down!" << endl;
	read.close();

	
	for (int i = 0; i < route.size(); i++){
		for (int j = 0; j < route[i].size(); j++)
			sort(route[i].begin(),route[i].end(),cmp);
	}
	cout << " sort down!" << endl;
	fstream write;
	write.open("scc.txt", ios::out);
	write << Size <<endl;
	for (int i = 0; i < Size; i++){
		write << i << "  ";//输出结点编号
		//write << route[i].size() << "  ";//输出邻居结点的个数
		//for (int j = 0; j < route[i].size(); j++){
		//	write << route[i][j].target<<"  "<<
		//}
		vector<int> sumSize; //分界点 计算每个最末出边邻居的下标
		int neiNum = 0; //计算出边邻居的个数
		vector<int> neiId;//出边邻居的id
		sumSize.resize(1);
		neiId.resize(1);
		if (route[i].size() == 0){
			write << 0 << endl;
			continue;
		}
		for (int j = 0; j < route[i].size() -1 ; j++){
			if (route[i][j].target != route[i][j + 1].target)
			{
				neiNum++;
				sumSize[sumSize.size() - 1] = j+1;
				sumSize.resize(sumSize.size() + 1);
				
				neiId[neiId.size() - 1] = route[i][j].target;
				neiId.resize(neiId.size() + 1);
			}
		}
		if (neiNum == 0){ //代表只有一个出边情况
			neiNum++;
			sumSize[0] = route[i].size();
			neiId[0] = route[i][0].target;
		}
		else if (neiNum != 0){ //代表出现不同，将存储最后一个结点
			neiNum++;
			sumSize[sumSize.size() - 1] = route[i].size();
			neiId[neiId.size() - 1] = route[i][route[i].size() - 1].target;
		}
		write << neiNum << "  "; //输出邻居的个数
		for (int j = 0; j < neiNum; j++){
			write << neiId[j] << "  ";//输出邻居结点的id
			int sum = j == 0 ? 0 : sumSize[j - 1];
			int goNei = sumSize[j] - sum;
			write << goNei << "  "; //有多少边去邻居点
			for (int k = sum; k < sumSize[j]; k++){
				write << route[i][k].dur << "  " << route[i][k].startT << "  " << route[i][k].mark << "  ";
				// 路程所花费的时间 图中边的权值 车辆的唯一id
			}
			write << endl;
		}
		write << endl;
	}
	
}
/*
	每一条线路 可以增加站点i的条数为 1 × 趟数
*/